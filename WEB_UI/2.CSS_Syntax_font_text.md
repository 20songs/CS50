# 웹 UI 개발

# 2. CSS 기초

## 2.0.Hello

> HTML & CSS 기초 소개

#### 학습하기 

> HTML&CSS 기초 강의는 실무에 많이 사용되는 HTML 태그 및 CSS 속성을 살펴봅니다.
>
> 강의 진행은 HTML&CSS 문법 및 특징을 간단히 살펴보고
> 실습을 통해 해당 코드가 브라우저에서 어떻게 표현되는지 확인합니다.
> 또한 퀴즈를 통해 학습한 내용을 올바르게 숙지했는지 스스로 점검할 수 있도록 합니다.
>
> 다양한 HTML 태그, CSS 속성의 문법과 주요 특징을 잘 숙지하시길 바랍니다.



## 2.1.CSS이해하기

### 1) CSS소개

---

#### 들어가기 전에

> HTML에 관한 내용은 이전 수업에서 마무리했고, 앞으로 다룰 내용은 Cascading Style Sheets(CSS)입니다.
>
> 웹 페이지를 사람에 비유해보자면, 마크업 언어(HTML)는 몸의 구조(뼈, 근육)를 담당하고
>
> CSS는 옷과 신발과 같이 외적으로 꾸며주는 역할을 한다고 생각하면 이해하기 쉽습니다.

#### 핵심 키워드

> - Cascading Style Sheets 

#### 학습하기

---

* **CSS와 HTML**

  CSS는 간단히 이야기하면 **HTML(마크업 언어)을 꾸며주는 표현용 언어**입니다.

  HTML이 문서의 정보, 구조를 설계한다면 CSS는 **문서를 보기 좋게 디자인**합니다.

  CSS는 분명히 HTML과는 독립된 다른 언어지만 **마크업 문서 자체가 존재하지 않으면 CSS는 무용지물**이나 마찬가지입니다.

  왜냐하면, CSS는 표현을 위한 언어인데 마크업 문서가 없다면 표현할 대상이 없기 때문입니다.

  그래서 CSS는 보통 마크업 언어인 HTML과 같이 묶어서 이야기합니다.

  

* **CSS로 표현한 다양한 웹 사이트들**

  전 세계에 많은 웹 사이트들이 있습니다.

  그리고 그것들 모두 HTML 태그를 이용해서 만들어졌고, 자주 사용되는 태그의 개수는 10여 개밖에 되지 않습니다.

  결국, 모든 사이트가 비슷한 HTML 태그를 사용해서 만들어졌음에도 불구하고 각각 다양하고 독창적인 디자인으로 표현 가능한 이유가 바로 CSS 덕분입니다.

  CSS는 문서를 디자인하는 강력한 힘을 가졌습니다. 

  아래 참고 링크를 방문하면 하나의 HTML이 다양한 CSS를 통해 바뀌는 것을 확인할 수 있습니다.

* **참고자료**

  http://www.csszengarden.com/

### 2) CSS 문법과 적용

---

#### 들어가기 전에

> CSS도 몇 개의 규칙을 제외하고는 HTML과 마찬가지로 정해진 많은 속성과 그에 해당하는 값의 집합으로 이루어져 있습니다.
>
> 이번 강의에서는 간단한 구문을 통해 CSS의 구성 요소와 규칙에 대해 배우고, CSS를 문서에 적용하는 방식에 대해 살펴보도록 하겠습니다.
>
>  

#### 핵심 키워드

> - CSS 구문
> - CSS 적용 방식

#### 학습하기

---

CSS는 HTML 요소를 꾸며주는 역할을 합니다.

CSS는 꾸밀 대상이 되는 요소와 그에 대한 스타일 내용으로 이루어져 있습니다.

 

**CSS 구문**

```css
h1 { color: yellow; font-size:2em; }
```

- 선택자(selector) - "h1"
- 속성(property) - "color"
- 값(value) - "yellow"
- 선언(declaration) - "color: yellow", "font-size: 2em"
- 선언부(declaration block) - "{ color: yellow; font-size:2em; }"
- 규칙(rule set) - "h1 { color: yellow; font-size:2em; }"

 

CSS 파일은 여러 개의 규칙으로 이루어져 있습니다.

**선택자와 선언부 사이, 선언과 선언 사이는 앞뒤로 개행**을 해도 상관이 없습니다.

하지만 **속성이름과 속성값 사이에는 개행을 하면 안 됩**니다.

 

[올바른 CSS]

```css
h1
{ color: yellow; font-size:2em; }

h1 {
    color: yellow;
    font-size:2em;
}
```



[잘못된 CSS]

```css
h1 {
    color:
    yellow;
}
```

**CSS의 속성(Property)과 HTML의 속성(Attribute)**

HTML에도 속성이 있고, CSS에도 속성이 있습니다. **두 가지는 전혀 다른 것**입니다.

**HTML의 속성은 영어로 attribute**이고, **CSS의 속성은 property**입니다.

둘 다 한국어로 번역할 때 "속성"이라고 하므로 잘 구분하셔야 합니다.

 

**CSS 주석**

CSS의 주석은 아래와 같이 선언합니다.

```css
/* 주석 내용 */
/*
    주석은 여러 줄로도
    선언 할 수 있습니다.
*/
```



**CSS의 적용**

CSS와 문서를 연결하는 방법은 4가지가 있습니다.

 

**1. Inline**

Inline은 **해당 요소에 직접 스타일 속성을 이용해서 규칙들을 선언하는 방법**입니다.

해당 요소에 직접 입력하기 때문에 **선택자는 필요하지 않게 되고, 선언부에 내용만 스타일 속성의 값으로 넣어주**면 됩니다.

Inline 스타일 방식이라고 부릅니다.

```html
<div style="color:red;"> 내용 </div>
```

Inline 스타일 방식은 **코드의 재활용이 되지 않기 때문에 자주 사용하지 않습니다.**

 

**2. Internal**

Internal은 **문서에 \<style>을 활용한 방법**입니다.

**\<style>은 \<head>내부에** 들어가며 **\<style>안에 스타일 규칙**이 들어갑니다.

```html
<style> div {color: red;} </style>
```

위의 코드로 모든 \<div>에 같은 스타일을 줄 수 있습니다.

**하지만 이것도 한계가 있습니다.**

많은 페이지가 있는 경우에는 **모든 페이지에 저마다의 규칙을 선언**해줘야 합니다.

**페이지가 많고 스타일 규칙 내용이 많아지면 결코 쉬운 일은 아닙니다**.

 

**3. External**

External은 외부 스타일 시트 파일을 이용한 방법입니다.

**외부 스타일 시트**는 스타일 규칙들을 별도의 외부 파일을 만들어 넣는 방식입니다.

외부 파일은 확장자가 .**css가 되며 css 파일**이라고 부릅니다.

```css
div {color: red;}
```

우선 CSS 파일을 하나 만들고 스타일 규칙을 선언합니다.

그다음 **\<link>을 이용해서 CSS 파일을 연결**하면 됩니다.

```html
<link rel="stylesheet" href="css/style.css">
```

**\<head> 내부에 \<link>를 선언한 후 href 속성을 이용해 CSS 파일의 경로를 적습니다**.

**rel 속성**은 **연결되는 파일이 문서와 어떤 관계인지를 명시하는 속성**으로, CSS 파일은 '**stylesheet**' 라고 적어야 합니다.

외부 스타일 시트 방식으로 스타일을 선언하면 많은 페이지가 있더라도 이 한 줄로 모든 페이지에 같은 스타일을 적용할 수 있습니다.

또한, 수정이 필요할 때도 CSS 파일을 수정하면 연결된 모든 페이지에 반영할 수 있습니다.

**외부 스타일 시트 방식은 파일 관리가 편하면서도 용량이 작기 때문에 주로 사용되는 방법입니다**.

 

**4. Import**

Import는 스타일 시트 내에서 다른 스타일 시트 파일을 불러오는 방식입니다.

```css
@import url("css/style.css");
```

\<style> 내부 상단이나 외부 스타일 시트 파일 상단에 선언하는데 성능상 좋지 않아서 거의 쓰이지 않습니다.

이에 본 강의에서는 다루지 않습니다. 궁금하신 분들은 따로 찾아보시길 바랍니다.

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>css</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <p>Hello, CSS</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Culpa debitis facere fuga laboriosam placeat provident, quibusdam quidem quo sapiente totam?</p>
</body>
</html>
```



### 3) 선택자 1

---

#### 들어가기 전에

> 선택자는 복잡하고 다양한 요소들 사이에서 내가 원하는 요소만을 선택할 수 있도록 도와줍니다.
>
> 완성도 있는 디자인을 표현하기 위해서는 반드시 내가 원하는 요소를 선택할 수 있어야 하기 때문에 선택자는 매우 중요합니다.
>
> 또 활용 수준에 따라 아주 기본적이면서도 매우 복잡하므로 기초 부분을 반드시 잘 이해해야 합니다.

#### 핵심 키워드

> - 요소 선택자
> - 그룹화 

#### 학습하기

---

* **요소 선택자**

  선택자 중에 가장 기본이 되는 선택자이며, 태그 선택자라고도 합니다.

  ```css
  h1 { color: yellow; }
  h2 { color: yellow; }
  h3 { color: yellow; }
  h4 { color: yellow; }
  h5 { color: yellow; }
  h6 { color: yellow; }
  ```

  요소 선택자는 위 코드처럼 **선택자 부분에 태그 이름**이 들어갑니다.

  문서 내에 선택자에 해당하는 **모든 요소에 스타일 규칙**이 적용됩니다.

   

* **그룹화**

  선택자는 **쉼표를 이용해서 그룹화**를 할 수 있습니다.

  ```css
  h1, h2, h3, h4, h5, h6 { color: yellow; }
  ```

  위 코드는 요소 선택자의 예제 코드와 같은 코드입니다.

  그리고 **전체 선택자** 라고 불리는 간단한 선택자도 있습니다.

  ```css
  * { color: yellow; }
  ```

  **\*(별표, asterisk) 기호로 문서 내에 모든 요소**를 선택할 수 있습니다.

  이렇게 선언하면, 한 번의 선언만으로 문서 내에 모든 요소에 스타일 규칙이 적용됩니다.

  **전체 선택자는 매우 편리하지만, 성능에 좋지 않으므로 될 수 있으면 사용을 지양**합니다.

  선택자뿐만 아니라 **선언들도 그룹화**가 가능합니다. 

  ```css
  h1 { color: yellow; font-size: 2em; background-color: gray; }
  ```

  그리고 마지막으로 **선택자와 선언이 동시에 그룹화**도 가능합니다.

  ```css
  h1, h2, h3, h4, h5, h6 { color: yellow; font-size: 2em; background-color: gray; }
  ```

  ------

  **코드실습**

  ```html
  <!DOCTYPE html>
  <html lang="ko">
  <head>
  	<meta charset="UTF-8">
  	<title>css</title>
  	<style>
  		h1 { color: yellow; font-size: 2em; background-color: gray; }
  	</style>
  </head>
  <body>
  	<h1>Hello, CSS</h1>
  	<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Culpa debitis facere fuga laboriosam placeat provident, quibusdam quidem quo sapiente totam?</p>
  </body>
  </html>
  ```



### 4) 선택자 3

---

#### 들어가기 전에

> 수업을 시작하기 전에 퀴즈를 준비했습니다.
>
> Q. 아래 HTML 문서에서 "HTML"이라는 문자에는 보라색 글자를 지정하고, "CSS"라는 문자에는 밑줄을 선언하고 싶으면 어떻게 선택자를 사용해야 할까요?
>
> (아직 CSS 속성을 배운 건 아니므로 선택자 부분만 생각하시면 됩니다.)
>
> ```html
> <dl>
>     <dt>HTML</dt>
>     <dd><span>HTML</span>은 문서의 구조를 나타냅니다.</dd>
>     <dt>CSS</dt>
>     <dd><span>CSS</span>는 문서의 표현을 나타냅니다.</dd>
> </dl>
> ```
>
> 이전 수업에서 배운 요소 선택자와 전체 선택자로는 원하는 요소를 선택해서 규칙을 적용하기는 불가능합니다.
>
> 만일 \<dt>에 컬러를 지정하면 밑에 \<dt>의 "CSS" 문자에도 적용될 것이고, 반대로 밑줄을 그으면 위에 \<dt>의 "HTML" 문자에도 적용되기 때문입니다.
>
> 그래서 더 다양한 선택자들이 있는데요.
>
> 이번 수업에서는 그중 가장 많이 사용하는 class 선택자와 id 선택자에 대해서 알아보도록 하겠습니다.

#### 핵심 키워드

> - class
> - id

#### 학습하기

---

**class** **선택자**

**요소에 구애받지 않고 스타일 규칙을 적용**할 수 있는 **가장 일반적인 방법은 class 선택자**를 활용하는 것입니다.

class 선택자를 사용하기 위해서는 **HTML을 수정해 class 속성을 추가**해야 합니다.

**class 속성은 글로벌 속성이므로 어느 태그에서도 사용**할 수 있습니다.

class 속성에 값을 넣게 되면, class 선택자를 이용해서 해당 요소에 스타일 규칙을 적용할 수 있습니다.

```css
.foo { font-size: 30px; }
<p class="foo"> ... </p>
```

위 코드처럼 \<p>의 class 속성의 값으로 "foo"라는 값을 넣었다면, CSS에서

그 값("foo")을 선택자로 지정하면 됩니다.

**클래스 선택자를 쓸 때는, 맨 앞에 .(마침표)를 찍어**주셔야 합니다.

이렇게 되면 어느 요소든지 class 속성값이 "foo"로 선언된 요소가 있다면 해당 스타일 규칙을 적용받게 됩니다.

그럼 이제 클래스 선택자를 이용해서 인트로에 제시했던 퀴즈를 풀어보겠습니다.

```css
.html { color: purple; }
.css { text-decoration: underline; }
<dl>
    <dt class="html">HTML</dt>
    <dd><span class="html">HTML</span>은 문서의 구조를 나타냅니다.</dd>
    <dt class="css">CSS</dt>
    <dd><span class="css">CSS</span>는 문서의 표현을 나타냅니다.</dd>
</dl>
```

**다중 class**

class 속성은 꼭 하나의 값만 가질 수 있는 것은 아닙니다.

**공백으로 구분하여 여러 개의 class 값**을 넣을 수 있습니다.

```css
.foo { font-size: 30px; }
.bar { color: blue; }
<p class="foo bar"> ... </p>
```

위의 \<p>에 class 속성에 "foo" 와 "bar" 2개의 값을 넣었습니다.

그리고 foo class 선택자에는 폰트의 크기를 30px로, bar class 선택자에는 글자를 파란색으로 적용하는 스타일 규칙이 선언되어있습니다.

그렇게 되면 이 \<p>에는 **2개의 규칙이 모두 적용**이 됩니다.

 

**id 선택자**

id 선택자는 class 선택자와 비슷합니다.

선택자를 쓸 때는, **.(마침표) 기호 대신 #(해시) 기호**를 써주시면 되고,

**요소에는 class 속성 대신 id 속성**만 써주면 됩니다.

```css
#bar { background-color: yellow; }
<p id="bar"> ... </p>
```

이 \<p>는 id 선택자의 스타일 규칙이 적용됩니다.

 

**class 선택자와의 차이점**

1. .기호가 아닌 #기호 사용
2. 태그의 class 속성이 아닌 id 속성을 참조
3. **문서 내에 유일한 요소에 사용**
4. **구체성** 

가장 큰 차이점은 class와 달리 id는 문서 내에서 유일해야 한다는 점입니다.

클래스 선택자는 여러 요소에 같은 클래스를 넣고 같은 규칙을 적용 할 수 있었습니다.

그리고 그것이 클래스 선택자의 장점이기도 합니다.

**하지만 id 속성값은 문서 내에 유일하게 사용이 되어야 합니다.**

결국, id 선택자로 규칙을 적용할 수 있는 요소는 단 하나뿐입니다.

그리고 마지막으로 구체성의 값이 다릅니다. (이에 대한 자세한 설명은 이후 구체성 수업에서 다룹니다.)

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>css</title>
	<style>
		.item { background: gray; }
		.a { color: yellow; }
		.b { color: blue; }
		#special { color: red; }
	</style>
</head>
<body>
	<ul>
		<li class="item a">first</a>
		<li class="item b">second</a>
		<li class="item" id="special">third</a>
	</ul>
</body>
</html>
```



### 5) 선택자 3

---

#### 들어가기 전에

> 앞선 선택자 강의에서는 하나의 선택자만을 사용해서 요소를 선택하는 법에 대해 배웠습니다.
>
> 선택자는 종류에 상관없이 여러 가지 선택자들을 조합하여 사용할 수 있습니다.
>
> 선택자를 조합하는 방식에 대해서 살펴보도록 하겠습니다.

#### 핵심 키워드

> - 속성 선택자

#### 학습하기

---

**선택자의 조합**

```css
/* 요소와 class의 조합 */
p.bar { ... }

/* 다중 class */
.foo.bar { ... }

/* id와 class의 조합 */
#foo.bar { ... }
```

**첫 번째는 요소와 클래스**를 조합한 경우입니다.

이 경우에는 \<p>이면서 class 속성에 bar가 있어야 적용됩니다.

**두 번째는 다중 클래스**의 경우입니다.

이 경우에는 class 속성에 foo와 bar가 모두 있어야 적용됩니다.

**마지막은 id와 class**를 조합한 경우입니다.

이 경우에는 id가 foo이며 class가 bar인 요소에 적용됩니다.

 

**속성 선택자**

* 단순 속성으로 선택
* 정확한 속성값으로 선택
* 부분 속성값으로 선택



**단순 속성으로 선택**

```css
p[class] { color: silver; }
p[class][id] { text-decoration: underline; }
<p class="foo">Hello</p>
<p class="bar">CSS</p>
<p class="baz" id="title">HTML</p>
```

속성 선택자는 **대괄호를 이용해서 선언**하며 **대괄호 안에 속성 이름**이 들어갑니다.

**요소에 해당 이름의 속성이 있다면 해당 사항이 적용**됩니다.

위 CSS 코드는 요소 선택자와의 조합으로 이루어진 코드입니다.

첫 번째는 \<p>이면서 class 속성이 있는 요소이면 color: silver 규칙이 적용됩니다.

두 번째는 \<p>이면서 class 속성과 id 속성이 함께 있어야 text-decoration: underline 규칙이 적용됩니다.

바로 위 HTML 코드에는 3개의 \<p>가 있습니다.

그렇다면 이 3개의 \<p>에는 각자 어떤 스타일이 적용될까요?

**먼저 예측을 하시고 직접 실습을 하는 게 좋습니다.**

p[class] 선택자의 규칙은 class 속성만 존재하면 적용이 되기 때문에 3가지 요소 모두에 적용됩니다. 

p[class]\[id] 선택자의 규칙은 class 속성과 id 속성 모두 있는 요소만 해당하기 때문에 마지막 요소에만 적용됩니다. 

두 규칙 모두 속성의 값은 상관하지 않습니다.

 

**정확한 속성값으로 선택**

정확한 속성값으로 선택은 **제목 그대로 속성의 값으로 요소를 선택**합니다.

**선택자는 대괄호 안에 속성 이름과 속성값을 다 적으면** 됩니다.

```css
p[class="foo"] { color: silver; }
p[id="title"] { text-decoration: underline; }
```

p[class="foo"]는 \<p>이면서 class 속성의 값이 foo이면 적용되고, p[id="title"]는 \<p> 이면서 id 속성의 값이 title이면 적용됩니다.

 

**부분 속성값으로 선택**

부분 속성값으로 선택은 속성 이름과 속성값 사이에 사용되는 기호에 따라 동작이 조금 다릅니다. 

- **[class~="bar"]** : class 속성의 값이 **공백으로 구분한** "bar" 단어가 포함되는 요소 선택
- **[class^="bar"] :** class 속성의 값이 "bar"로 **시작하는** 요소 선택
- **[class$="bar"]** : class 속성의 값이 "bar"로 **끝나는** 요소 선택
- **[class*="bar"]** : class 속성의 값이 "bar" **문자가 포함되는 요소** 선택

```html
<p class="color hot">red</p>
<p class="cool color">blue</p>
<p class="colorful nature">rainbow</p>
```

위의 코드에서는 모두 class 속성값으로 "color"를 선택합니다.

요소 순서대로 기호에 따라 규칙이 적용되는 결과는 다음과 같습니다.

```css
p[class~="color"] { font-style: italic; } /* 1, 2번째 요소 */
p[class^="color"] { font-style: italic; } /* 1, 3번째 요소 */
p[class$="color"] { font-style: italic; } /* 2번째 요소 */
p[class*="color"] { font-style: italic; } /* 1, 2, 3번째 요소 */
```

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>css</title>
	<style>
		p[class$="color"] { font-style: italic; }
	</style>
</head>
<body>
	<p class="color hot">red</p>
	<p class="cool color">blue</p>
	<p class="colorful nature">rainbow</p>
</body>
</html>
```



### 6) 문서 구조 관련 선택자

---

#### 들어가기 전에

> 선택자 중에는 문서의 구조를 이용하여 요소를 선택하는 선택자도 있습니다.
>
> 문맥이나 요소의 구조를 기반으로 하여 선택자를 조합하는 것을 "조합자" 또는 "결정자" 라고 부릅니다.
>
> 이 조합자를 이용하면 문서 구조를 이용해 좀 더 유연하게 요소를 선택하고 스타일을 적용할 수 있습니다.

#### 핵심 키워드

> - 부모와 자식 관계
> - 조상과 자손 관계
> - 형제 관계

#### 학습하기

---

* **문서 구조의 이해**

  선택자와 문서의 관계를 이해하기 위해 먼저 어떻게 문서가 구조화되는지를 다시 한 번 살펴보겠습니다

  ```html
  <html>
  <body>
      <div>
          <h1><span>HTML</span>: Hyper Text Markup Language</h1>
      </div>
      <p>HTML과 CSS와 JAVASCRIPT를 이용해서 멋진 웹 사이트를 제작할 수 있습니다.</p>
  </body>
  </html>
  ```

  위 HTML 코드에서 각 요소들을 짚어가면서 부모와 자식, 조상과 자손, 그리고 형제의 관계를 살펴보겠습니다. (참고: 영상의 예제 코드와 조금 다릅니다.)

   

* **부모와 자식**

  부모 요소는 **그 요소를 포함하는 가장 가까운 상위 요소로, 그 요소의 부모 요소는 단 하나뿐**입니다.

  자식 요소는 부모 요소와 반대라고 생각하면 되며 자식 요소는 여러 개일 수도 있습니다.

  - \<body>의 부모 요소: \<html> ↔ \<html>의 자식 요소: \<body>
  - \<div>의 부모 요소: \<body> ↔ \<body>의 자식 요소: \<div>, \<p>
  - \<h1>의 부모 요소: \<div> ↔ \<div>의 자식 요소: \<h1>
  - \<span>의 부모 요소: \<h1> ↔ \<h1>의 자식 요소: \<span> 
  - \<p>의 부모 요소: \<body> ↔ \<body>의 자식 요소: \<div>, \<p>

   

* **조상과 자손**

  조상과 자손의 관계는 **부모와 자식의 관계와 비슷**합니다.

  정확히 얘기하면 **부모와 자식의 관계를 포함한 확장된 관계**라고 생각하면 됩니다.

  조상 요소는 그 요소를 포함하는 모든 요소로, **부모 요소를 포함하여 여러 개일 수도** 있습니다.

  자손 요소는 그 반대로, **그 요소가 포함하고 있는 모든 요소가 자손 요소**입니다.

  - \<body>의 조상 요소: \<html> ↔ \<html>의 자손 요소: \<body>, \<div>, \<h1>, \<span>, \<p>
  - \<div>의 조상 요소: \<html>, \<body> ↔ \<body>의 자손 요소: \<div>, \<h1>, \<span>, \<p>
  - \<h1>의 조상 요소: \<html>, \<body>, \<div> ↔ \<div>의 자손 요소: \<h1>, \<span>
  - \<span>의 조상 요소: \<html>, \<body>, \<div>, \<h1> ↔ \<h1>의 자손 요소: \<span>
  - \<p>의 조상 요소: \<html>, \<body> ↔ \<body>의 자손 요소: \<div>, \<h1>, \<span>, \<p>

   

  보통 문서의 요소들은 모두 이처럼 어느 요소의 자식(자손) 요소이자 부모(조상) 요소가 되는 경우가 많습니다.

   

* **형제**

  부모와 자식, 조상과 자손 말고도 형제 관계도 있습니다.

  **같은 부모를 가지고 있는 요소들은 서로 형제 관계**에 있습니다.

  위 코드에서는 \<div>, \<p>가 형제 요소입니다.

  형제 관계 중에는 **인접한 관계**도 있습니다.

  형제 관계에 있는 요소 중 **바로 뒤에 이어 나오는 요소를 인접**해 있다고 합니다.

  여기서 \<p>가 \<div>에 인접한 형제 요소가 됩니다.

  문서의 구조는 흔히 가계도나 조직도의 관계와 비슷하다고 생각하면 이해하기가 쉽습니다.

   

  **문서 구조 관련 선택자**

  문서 구조를 이용한 선택자는 3가지 있습니다.

  자손 선택자와 자식 선택자 그리고 인접 선택자입니다.

  문서 구조를 잘 이해하셨다면 쉽게 예측할 수 있습니다.

   

* **자손 선택자**

  ```css
  div span { color: red; }
  ```

  자손 선택자는 선택자 사이에 **아무 기호없이 그냥 공백**으로 구분을 합니다. 

  이 선택자는 \<div>의 자손 요소인 \<span>를 선택하는 선택자 입니다.

   

* **자식 선택자**

  ```css
  div > h1 { color: red; }
  ```

  자식 선택자는 선택자 사이에 닫는 **꺽쇠 기호(>)**를 넣습니다.

  **꺽쇠 기호와 선택자 기호 사이에는 공백은 있거나 없어도 상관이 없습니다.**

  이 선택자는 \<div>의 자식 요소인 \<h1>를 선택하는 선택자 입니다.

   

* **인접 형제 선택자**

  ```css
  div + p { color: red; }
  ```

  **인접 형제** **선택자는 선택자 사이에 + 기호**를 넣습니다.

  자식 선택자와 마찬가지로 공백은 있거나 없어도 상관이 없습니다.

  인접 형제 선택자는 **형제 관계이면서 바로 뒤에 인접해 있는 요소를 선택하는 선택자**입니다.

  ```css
  /* body 요소의 자식인 div 요소의 자손인 table 요소 바로 뒤에 인접한 ul 요소 선택! */
  
  body > div table + ul { ... }
  ```

  위 코드처럼 문서 구조 관련 선택자는 더 복잡하게 사용할 수 있습니다.

  **유의할 점은 요소들이 많이 나열되어 있더라도 제일 우측에 있는 요소가 실제 선택되는 요소**라는 것입니다.

   

  ------

   

  **생각해보기**

  또 다른 형제 선택자인 ~(틸트) 에 대해서 공부해보세요.

  https://www.w3schools.com/cssref/sel_gen_sibling.asp



### 7) 가상 선택자 1

---

#### 들어가기 전에

> 가상 선택자에는 가상 클래스와 가상 요소가 있습니다.
>
> 가상 클래스 선택자는 특정 요소의 상태를 미리 추정해서 가상의 클래스로 스타일을 적용할 수 있는 선택자입니다.
>
> 앞서 배운 class 선택자와는 조금 다르지만, 마치 클래스 선택자처럼 동작하기에 가상 클래스 선택자라고 부릅니다.
>
> 이번 수업에서는 가상클래스 선택자에는 어떤 종류들이 있고, 어떻게 동작하는지 알아보도록 하겠습니다. 
>
> 먼저 가상 클래스에 대해서 살펴보겠습니다.

#### 핵심 키워드

> - 가상 클래스

#### 학습하기

---

* **가상 클래스(pseudo class)**

  가상 클래스는 **미리 정의해놓은 상황에 적용되도록 약속된 보이지 않는 클래스**입니다.

  우리가 직접 요소에 클래스를 선언하는 것은 아니고, **약속된 상황이 되면 브라우저 스스로 클래스를 적용**해줍니다.

  예를 들어, \<p>가 있다고 가정하겠습니다.

  이 \<p>에 마우스 커서를 올렸을 때만 특정 스타일을 주고 싶다고 한다면 어떻게 해야 할까요?

  

  가상 클래스가 없다면 이런 과정을 거치게 됩니다.

  1. 임의의 클래스 선택자를 선언하여 특정 스타일 규칙을 만든다.
  2. p 요소에 커서가 올라가면 p 요소에 클래스를 집어넣는다.
  3. p 요소에서 커서가 빠지면 p 요소에 클래스를 삭제한다.

  여기서 2, 3번은 동적으로 변화되어야 하는데, HTML과 CSS는 정적인 언어이기 때문에 처리할 수 없습니다.

  어쩔 수 없이 다른 언어를 사용해야 하는데, 이는 개발 비용이 들어가는 일입니다.

  

  그래서 CSS에서는 흔하게 사용되는 여러 패턴에 대해서 미리 정의해놓고, 가상 클래스로 제어할 수 있게 했습니다.

  ```css
  :pseudo-class {
      property: value;
  }
  ```

  위처럼 **가상 클래스는 :(콜론) 기호를 써서** 나타냅니다.

  가상 클래스를 이용하면 아래의 경우에도 CSS만으로 처리가 가능하므로 훨씬 효율적입니다.

  **":hover 가상 클래스 선택자를 이용해서 스타일 규칙을 만든다. (hover는 마우스 커서가 올라갔을 때 적용이 되도록 정의되어 있습니다.)"**

  가상 클래스에는 여러 가지가 있습니다.

  이 수업에서는 가장 기초적이고 대표적인 가상 클래스만을 설명해 드리기 때문에 아래 링크를 참고 직접 공부하시길 바랍니다.

  https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes

   

* **문서 구조와 관련된 가상 클래스**

  문서 구조와 관련된 가상 클래스는 first-child와 last-child 가상 클래스 선택자 입니다.

  - **:first-child : 첫 번째 자식 요소 선택**

  - **:last-child : 마지막 자식 요소 선택**

  ```css
  li:first-child { color: red; }
  li:last-child { color: blue; }
  
  <ul>
      <li>HTML</li>
      <li>CSS</li>
      <li>JS</li>
  </ul>
  ```

  **첫 번째 \<li>와 마지막 \<li>에 가상 클래스가 적용**됩니다.

  **실제 \<li>에는 class 속성이 없지만 내부적으로 가상 클래스가 적용**되어 마치 아래의 코드와 같이 동작하게 됩니다.

  ```html
  <ul>
      <li class="first-child">HTML</li>
      <li>CSS</li>
      <li class="last-child">JS</li>
  </ul>
  ```

   

* **앵커 요소와 관련된 가상 클래스**

  앵커 요소와 관련된 가상 클래스로는 **:link와 :visited**가 있습니다.

  - **:link : 하이퍼 링크이면서 아직 방문하지 않은 앵커**

  - **:visited : 이미 방문한 하이퍼링크를 의미**

  하이퍼 링크는 앵커 요소에 href 속성이 있는 것을 의미합니다.

  ```css
  a:link { color: blue; }
  a:visited { color: gray; }
  ```

   

* **사용자 동작과 관련된 가상 클래스**

  이 클래스들도 \<a>에 주로 많이 쓰입니다.

  \<a>에만 쓸 수 있는 것은 아니며, 이 조건에 맞는 상황이 되는 요소들은 다 사용이 가능합니다.

  - **:focus: 현재 입력 초점을 가진 요소에 적용**
  - **:hover: 마우스 포인터가 있는 요소에 적용**
  - **:active: 사용자 입력으로 활성화된 요소에 적용**

  ```css
  a:focus { background-color: yellow; }
  a:hover { font-weight: bold; }
  a:active { color: red; }
  ```

  :focus는 현재 입력 초점을 가진 요소에 적용됩니다.

  **focus(초점)는 지금 현재 선택을 받는 것**을 의미합니다.

  예를 들면, 입력 폼 요소에 텍스트를 입력하려고 **마우스 클릭**해서 커서를 입력 폼 위에 올려놓으면 그때 입력 폼 요소가 초점을 받는 상태입니다.

  또 **키보드의 탭 키**를 이용해서 요소를 탐색하다 보면 링크나 버튼에 점선 테두리가 이동하는 것을 볼 수 있는데, **점선 테두리가 위치하는 것**도 초점을 받은 상태입니다.

  :**hover는 마우스 커서가 있는 요소**에 적용됩니다. (마우스를 올렸을 때를 의미합니다.)

  :active는 사용자 입력으로 활성화된 요소를 의미하는데, **\<a>를 클릭할 때 또는 \<button>를 눌렀을 때**처럼 순간적으로 활성화됩니다.

   

  ------

   

  **코드실습**

  ```html
  <!DOCTYPE html>
  <html lang="ko">
  <head>
  	<meta charset="UTF-8">
  	<title>css</title>
  	<style>
  		a:focus { background-color: yellow }
  		a:hover { font-weight: bold }
  		a:active { color: red }
  	</style>
  </head>
  <body>
  	<a href="http://www.naver.com">네이버</a>
  	<a href="http://www.google.com">구글</a>
  	<a href="http://www.daum.net">다음</a>
  </body>
  </html>
  ```



### 8) 가상 선택자 2

---

#### 들어가기 전에

> 가상 요소는 가상 클래스와 비슷합니다. 다만 클래스가 아닌 요소라는 점만 다릅니다.
>
> 가상 요소는 현재 문서 내에 존재하지 않는 구조, 즉 문서에 존재하지 않는 요소에 내용을 추가할 수 있고, 또 스타일도 부여할 수 있습니다.
>
> 예를 들어 가장 자주 쓰이는 가상 요소는, 요소의 앞이나 뒤에 별도의 내용을 추가하는 것입니다.
>
> 이 때 추가되는 새 콘텐츠는 HTML 코드에 직접 추가되지 않고 브라우저 화면에만 나타납니다.

#### 핵심 키워드

> - 가상 요소 선택자

#### 학습하기

---

* **가상 요소(pseudo element)**

  가상 요소는 HTML 코드에 **존재하지 않는 구조 요소에 스타일을 부여**할 수가 있습니다.

  가상 요소도 **가상 클래스처럼 문서 내에 보이지 않지만, 미리 정의한 위치에 삽입되도록 약속**이 되어있습니다.

  **선언** 방법은 **가상 클래스와 같게 콜론을 사용**하며,

  CSS3부터는 가상 클래스와 가상 요소를 구분하기 위해 **가상 요소에는 ::(더블 콜론) 기호를 사용**하기로 했습니다.

  하지만 **하위 브라우저에서 :: 문법을 지원하지 않는 문제가 있으므로 상황에 따라 : 기호를 사용**하셔야 합니다.

  ```css
  ::pseudo-element {
      property: value;
  }
  ```

  강의에서는 가상 클래스와 마찬가지로 기본적인 가상 요소만 설명해 드리고 마치도록 하겠습니다.

  다른 가상 요소들에 대한 자세한 내용은 아래 링크를 참고해주세요.

  https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements 

  - **:before** : **가장 앞**에 요소를 삽입
  - **:after** : **가장 뒤**에 요소를 삽입
  - **:first-line** : **요소의 첫 번째 줄에 있는 텍스트**
  - **:first-letter** : **블록 레벨 요소의 첫 번째 문자**

  ```html
  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
  ```

  **before와 after 가상 요소는** 애초에 내용이 없는 상태로 생성되기 때문에 **내용을 넣기 위해 content 속성을 이용**해야 합니다.

  실제 HTML 코드에는 나타나지 않지만, before와 after가 어떻게 동작하는지 이해를 돕기 위해 코드를 아래와 같이 변경했습니다.

  ```css
  p::before { content: "###" }
  p::after { content: "!!!" }
  ```

  ```html
  <p>
      <before>###</before>
      Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
      <after>!!!</after>
  </p>
  ```

  눈에 보이지 않지만, 내부에서 이처럼 요소가 생성됩니다.

  first-line과 first-letter도 마찬가지로 아래 코드와 같은 것으로 생각하시면 됩니다.

  ```css
  p::first-line { ... }
  p::first-letter { ... }
  ```

  ```html
  <p>
      <first-letter>L</first-letter>orem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
  </p>
  <p>
      <!-- 모니터 가로 해상도에 따라 요소가 포함하는 내용이 변동됩니다. -->
      <first-line>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiu ..(..어딘가쯤..) </first-line>... unt ut labore et dolore magna aliqua.
  </p>
  ```

   

  ------

   

  **생각해보기**

  - 6개의 강의에 걸쳐 선택자에 대해서 알아보았습니다. 강의에서 다룬 선택자외에도 수많은 선택자들이 존재합니다.
    예를들면 first-line, nth-child 등 과 같이 순서와 관련된 선택자들이 있습니다. 
    또 그 선택자들마다 지원 브라우저 범위가 제각각이기 때문에 잘 확인하고 사용해야합니다.
  -  https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize--net-16048

### 9) 구체성

---

#### 들어가기 전에

> 어떤 요소에 적용된 CSS 스타일이 상충할 때 어떤 스타일을 적용할지 결정하기 위해
>
> 브라우저는 각 스타일에 구체성을 부여하고 판단하여 우선으로 적용할 것을 선택합니다.

#### 핵심 키워드

> - 구체성
> - 

#### 학습하기

---

**구체성**

요소를 선택하는 데는 여러 방법이 있습니다.

따라서 서로 다른 선택자를 이용해 같은 요소를 선택할 수도 있습니다.

만약 **같은 요소를 선택하는 서로 다른 규칙들이 상반된 스타일을 가지고 있다면 어떻게 표현이 될까요**?

```css
h1 { color: red; }
body h1 { color: green; }
```

두 규칙은 모두 \<h1>을 선택하게 됩니다.

하지만 두 규칙이 지정하는 스타일은 서로 다릅니다.

그렇다면 \<h1>은 어떻게 표현이 될까요?

\<h1>에는 color: green이 적용되는데 이는 구체성과 연관이 있습니다.

 

**선택자에는 어떤 규칙이 우선으로 적용되어야 하는지에 대해 정해진 규칙**이 있습니다.

이 규칙을 '**구체성**'이라고 합니다.

**구체성은 선택자를 얼마나 명시적으로(구체적으로) 선언했느냐를 수치화한 것으로,**

**구체성의 값이 클수록 우선으로 적용이 됩니다.**

```markup
0, 0, 0, 0
```

위와 같이 구체성은 4개의 숫자 값으로 이루어져 있습니다.

값을 비교할 때는 좌측에 있는 값부터 비교하며, 좌측 부분의 숫자가 클수록 높은 구체성을 갖습니다.

구체성은 아래의 규칙대로 계산됩니다. 

-  0, 1, 0, 0 : 선택자에 있는 모든 id 속성값
-  0, 0, 1, 0 : 선택자에 있는 모든 class 속성값, 기타 속성, 가상 클래스
-  0, 0, 0, 1 : 선택자에 있는 모든 요소, 가상 요소
-  전체 선택자는 0, 0, 0, 0을 가진다.
-  **조합자는 구체성에 영향을 주지 않는다. (>, + 등)**

```css
h1 { ... }  /* 0,0,0,1 */
body h1 { ... }  /* 0,0,0,2 */
.grape { ... }  /* 0,0,1,0 */
*.bright { ... }  /* 0,0,1,0 */
p.bright em.dark { ... }  /* 0,0,2,2 */
#page { ... }  /* 0,1,0,0 */
div#page { ... }  /* 0,1,0,1 */
```

**선택자의 구체성 값을 잘 알아야 많은 스타일 규칙들을 정의할 때 의도하지 않은 일이 생기지 않습니다.**

 

**인라인 스타일**

지금까지 선택자의 구체성에 대해 살펴봤습니다.

그렇다면 인라인 스타일로 선언된 경우에는 어떻게 될까요?

```css
p#page { color: red; }
<p id="page" style="color:blue">Lorem impusm dolor sit.</p>
```

첫 번째는 0, 1, 0, 1의 구체성을 가지는 선택자로 스타일을 선언했고,

두 번째는 요소에 직접 인라인 스타일 방식으로 스타일을 선언했습니다.

결과적으로 \<p>에는 color: blue가 적용됩니다.

**인라인 스타일의 구체성 값은 1, 0, 0, 0이며 규칙들 중 가장 큰 구체성**을 갖기 때문입니다.

 

**important**

important 키워드는 **별도의 구체성 값은 없지만, 모든 구체성을 무시하고 우선권**을 갖습니다.

important 키워드는 속성값 뒤 한 칸 공백을 주고 느낌표 기호와 함께 씁니다.

```css
p#page { color: red !important; }
<p id="page" style="color:blue">Lorem impusm dolor sit.</p>
```

위의 \<p>에는 important로 인해 color: red가 적용됩니다.



### 10) 상속

---

#### 들어가기 전에

> CSS에서 상속은 우리가 기본적으로 알고 있는 부모가 가진 특성을 자식이 물려받는 개념과 같습니다.
>
> 어떤 스타일 규칙이 특정 요소뿐만 아니라 그 자손 요소까지 적용되는 것을 말합니다.
>
> 상속은 구체성과 더불어 스타일 규칙들이 문서에 어떻게 적용되는지 이해하기 위한 또 다른 중요한 핵심 개념입니다.
>
> 상속 관계를 잘 활용하여 CSS의 생산성을 높일 수 있습니다.

#### 핵심 키워드

> - 상속
> - 구체성

#### 학습하기

---

**상속되는 속성**

```css
h1 { color: gray; }
<h1>Hello, <em>CSS</em></h1>
```

위 코드에서 **\<em>은 부모인 \<h1>의 color: gray를 상속받습니다**.

상속은 자연스러운 현상처럼 보이지만, **모든 속성이 다 상속되는 것은 아닙니다.**

아직 속성에 대해 다 배우지는 않았지만, **margin, padding, background, border 등 박스 모델 속성들은 상속되지 않는다는 것**을 알고 계시면 됩니다.

상속되는 속성들은 보통 상식적으로 구분될만한 속성들이며, 후에 속성들에 대해 배우게 되면 자연스럽게 이해할 수 있습니다.

 

**상속되는 속성의 구체성**

```css
* { color: red; }
h1#page { color: gray; }
<h1 id="page">Hello, <em>CSS</em></h1>
```

위 코드에서는 전체 선택자를 이용해 color: red를 적용하고 id 선택자를 이용해 color: gray를 선언했습니다.

**전체 선택자의 구체성은 0, 0, 0, 0 이며 id 선택자의 구체성은 0,1,0,1** 입니다.

그렇다면 \<em>에는 어떤 color가 적용될까요?

**color: red가 적용되는데 그 이유는 바로 상속된 속성은 아무런 구체성을 가지지 못하기 때문**입니다.



### 11) 캐스케이딩

---

#### 들어가기 전에

> cascading은 스타일 규칙들이 어떠한 기준으로 요소에 적용되는지를 정한 규칙입니다.
>
> cascading은 폭포가 내려오는 모양처럼 단계적인 이라는 의미를 지니며,
>
> 모든 스타일 규칙들은 cascading의 단계적인 규칙에 따라 요소에 적용됩니다.

#### 핵심 키워드

> - cascading

#### 학습하기

---

* 앞서 배운 구체성은 cascading 규칙 중 하나입니다.

  만약 구체성이 같은 두 규칙이 동일한 요소에 적용된다면 어떻게 될까요?

  ```css
  h1 { color: red; }
  h1 { color: blue; }
  ```

  위 \<h1>에는 같은 구체성을 가진 두 규칙이 적용되었습니다.

  그렇다면 \<h1>에는 어떤 color가 적용될까요?

  \<h1>에는 color: blue가 적용되며 이는 cascading 규칙에 의해 적용된 결과입니다.

   

  **cascading 규칙** 

  cascading에는 다음과 같이 3가지 규칙이 있습니다.

  1. **중요도(!important)와 출처**
  2. **구체성**
  3. **선언 순서**

  위에서의 출처는 CSS 출처를 의미합니다.

  **CSS 출처**는 **제작자와** **사용자**, 그리고 **사용자 에이전트(user agent)** 경우로 구분합니다.

  제작자의 경우는 사이트를 실제 제작하는 개발자가 작성한 CSS를 의미합니다. (**대부분이 여기**에 해당합니다.)

  그리고 사용자의 경우는 **웹 페이지를 방문하는 일반 사용자들이 작성**한 CSS를 의미합니다.

  마지막으로 사용자 에이전트의 경우는 일반 사용자의 환경, **즉 브라우저에 내장된 CSS**를 의미합니다.

  현재의 브라우저에서는 사용자 스타일을 지원하지 않는 추세이기 때문에 이와 관련해서는 생략하도록 하겠습니다.

  

* 우선순위

  사용자 !important 

  제작자 !important

  제작자

  사용자

  사용 에이전트

   

  스타일이 적용되는 방식은 생각보다 간단합니다.

  모든 스타일은 아래의 규칙에 따라 단계적으로 적용됩니다.

   

  1. 스타일 규칙들을 모아서 **중요도가 명시적으로 선언되었는지**에 따라 분류합니다.

  2. 1. 중요도가 명시적으로 선언된 규칙들은 그렇지 않은 규칙들보다 우선합니다.
     2. 중요도가 있는 규칙들끼리는 아래 다른 규칙들을 적용받습니다.

  3. 스타일 규칙들을 **출처**에 따라 분류합니다.

  4. 1. **제작자 스타일 규칙**이 사용자 에이전트 스타일 규칙보다 **우선합니다**.

  5. 스타일 규칙들을 **구체성에** 따라 분류합니다.

  6. 1. 구체성이 높은 규칙들이 우선합니다.

  7. 스타일 규칙들을 **선언 순서**에 따라 분류합니다.

  8. 1. 뒤에 선언된 규칙일수록 우선합니다.

  ```html
  <p id="bright">Hello, CSS</p>
  p#bright { color: silver; } 
  p { color: red; }
  ```

  위의 경우에는 **구체성에 따라 color: silver**가 적용됩니다.

  ```css
  p { color: silver; }
  p { color: red; }
  ```

  위의 경우에는 **선언 순서에 따라 color: red**가 적용됩니다.



### 12) 선택자 정리

---

#### 들어가기 전에

> 아래 참고 링크는 w3schools의 CSS Selector Reference 페이지 입니다.
>
> 영상에서 다루지 못한 선택자들도 많이 있으니 보시고 연습해보세요.

#### 학습하기

---

| Selector                                                     | Example               | Example description                                          |
| :----------------------------------------------------------- | :-------------------- | :----------------------------------------------------------- |
| [.*class*](https://www.w3schools.com/cssref/sel_class.asp)   | .intro                | Selects all elements with class="intro"                      |
| *.class1.class2*                                             | .name1.name2          | Selects all elements with both *name1* and *name2* set within its class attribute |
| *.class1 .class2*                                            | .name1 .name2         | Selects all elements with *name2* that is a descendant of an element with *name1* |
| [#*id*](https://www.w3schools.com/cssref/sel_id.asp)         | #firstname            | Selects the element with id="firstname"                      |
| [*](https://www.w3schools.com/cssref/sel_all.asp)            | *                     | Selects all elements                                         |
| *[element](https://www.w3schools.com/cssref/sel_element.asp)* | p                     | Selects all <p> elements                                     |
| *[element.class](https://www.w3schools.com/cssref/sel_element_class.asp)* | p.intro               | Selects all <p> elements with class="intro"                  |
| *[element,element](https://www.w3schools.com/cssref/sel_element_comma.asp)* | div, p                | Selects all <div> elements and all <p> elements              |
| [*element* *element*](https://www.w3schools.com/cssref/sel_element_element.asp) | div p                 | Selects all <p> elements inside <div> elements               |
| [*element*>*element*](https://www.w3schools.com/cssref/sel_element_gt.asp) | div > p               | Selects all <p> elements where the parent is a <div> element |
| [*element*+*element*](https://www.w3schools.com/cssref/sel_element_pluss.asp) | div + p               | Selects all <p> elements that are placed immediately after <div> elements |
| [*element1*~*element2*](https://www.w3schools.com/cssref/sel_gen_sibling.asp) | p ~ ul                | Selects every <ul> element that are preceded by a <p> element |
| [[*attribute*\]](https://www.w3schools.com/cssref/sel_attribute.asp) | [target]              | Selects all elements with a target attribute                 |
| [[*attribute*=*value*\]](https://www.w3schools.com/cssref/sel_attribute_value.asp) | [target=_blank]       | Selects all elements with target="_blank"                    |
| [[*attribute*~=*value*\]](https://www.w3schools.com/cssref/sel_attribute_value_contains.asp) | [title~=flower]       | Selects all elements with a title attribute containing the word "flower" |
| [[*attribute*\|=*value*\]](https://www.w3schools.com/cssref/sel_attribute_value_lang.asp) | [lang\|=en]           | Selects all elements with a lang attribute value starting with "en" |
| [[*attribute*^=*value*\]](https://www.w3schools.com/cssref/sel_attr_begin.asp) | a[href^="https"]      | Selects every <a> element whose href attribute value begins with "https" |
| [[*attribute*$=*value*\]](https://www.w3schools.com/cssref/sel_attr_end.asp) | a[href$=".pdf"]       | Selects every <a> element whose href attribute value ends with ".pdf" |
| [[*attribute**=*value*\]](https://www.w3schools.com/cssref/sel_attr_contain.asp) | a[href*="w3schools"]  | Selects every <a> element whose href attribute value contains the substring "w3schools" |
| [:active](https://www.w3schools.com/cssref/sel_active.asp)   | a:active              | Selects the active link                                      |
| [::after](https://www.w3schools.com/cssref/sel_after.asp)    | p::after              | Insert something after the content of each <p> element       |
| [::before](https://www.w3schools.com/cssref/sel_before.asp)  | p::before             | Insert something before the content of each <p> element      |
| [:checked](https://www.w3schools.com/cssref/sel_checked.asp) | input:checked         | Selects every checked <input> element                        |
| [:default](https://www.w3schools.com/cssref/sel_default.asp) | input:default         | Selects the default <input> element                          |
| [:disabled](https://www.w3schools.com/cssref/sel_disabled.asp) | input:disabled        | Selects every disabled <input> element                       |
| [:empty](https://www.w3schools.com/cssref/sel_empty.asp)     | p:empty               | Selects every <p> element that has no children (including text nodes) |
| [:enabled](https://www.w3schools.com/cssref/sel_enabled.asp) | input:enabled         | Selects every enabled <input> element                        |
| [:first-child](https://www.w3schools.com/cssref/sel_firstchild.asp) | p:first-child         | Selects every <p> element that is the first child of its parent |
| [::first-letter](https://www.w3schools.com/cssref/sel_firstletter.asp) | p::first-letter       | Selects the first letter of every <p> element                |
| [::first-line](https://www.w3schools.com/cssref/sel_firstline.asp) | p::first-line         | Selects the first line of every <p> element                  |
| [:first-of-type](https://www.w3schools.com/cssref/sel_first-of-type.asp) | p:first-of-type       | Selects every <p> element that is the first <p> element of its parent |
| [:focus](https://www.w3schools.com/cssref/sel_focus.asp)     | input:focus           | Selects the input element which has focus                    |
| [:hover](https://www.w3schools.com/cssref/sel_hover.asp)     | a:hover               | Selects links on mouse over                                  |
| [:in-range](https://www.w3schools.com/cssref/sel_in-range.asp) | input:in-range        | Selects input elements with a value within a specified range |
| [:indeterminate](https://www.w3schools.com/cssref/sel_indeterminate.asp) | input:indeterminate   | Selects input elements that are in an indeterminate state    |
| [:invalid](https://www.w3schools.com/cssref/sel_invalid.asp) | input:invalid         | Selects all input elements with an invalid value             |
| [:lang(*language*)](https://www.w3schools.com/cssref/sel_lang.asp) | p:lang(it)            | Selects every <p> element with a lang attribute equal to "it" (Italian) |
| [:last-child](https://www.w3schools.com/cssref/sel_last-child.asp) | p:last-child          | Selects every <p> element that is the last child of its parent |
| [:last-of-type](https://www.w3schools.com/cssref/sel_last-of-type.asp) | p:last-of-type        | Selects every <p> element that is the last <p> element of its parent |
| [:link](https://www.w3schools.com/cssref/sel_link.asp)       | a:link                | Selects all unvisited links                                  |
| [:not(*selector*)](https://www.w3schools.com/cssref/sel_not.asp) | :not(p)               | Selects every element that is not a <p> element              |
| [:nth-child(*n*)](https://www.w3schools.com/cssref/sel_nth-child.asp) | p:nth-child(2)        | Selects every <p> element that is the second child of its parent |
| [:nth-last-child(*n*)](https://www.w3schools.com/cssref/sel_nth-last-child.asp) | p:nth-last-child(2)   | Selects every <p> element that is the second child of its parent, counting from the last child |
| [:nth-last-of-type(*n*)](https://www.w3schools.com/cssref/sel_nth-last-of-type.asp) | p:nth-last-of-type(2) | Selects every <p> element that is the second <p> element of its parent, counting from the last child |
| [:nth-of-type(*n*)](https://www.w3schools.com/cssref/sel_nth-of-type.asp) | p:nth-of-type(2)      | Selects every <p> element that is the second <p> element of its parent |
| [:only-of-type](https://www.w3schools.com/cssref/sel_only-of-type.asp) | p:only-of-type        | Selects every <p> element that is the only <p> element of its parent |
| [:only-child](https://www.w3schools.com/cssref/sel_only-child.asp) | p:only-child          | Selects every <p> element that is the only child of its parent |
| [:optional](https://www.w3schools.com/cssref/sel_optional.asp) | input:optional        | Selects input elements with no "required" attribute          |
| [:out-of-range](https://www.w3schools.com/cssref/sel_out-of-range.asp) | input:out-of-range    | Selects input elements with a value outside a specified range |
| [::placeholder](https://www.w3schools.com/cssref/sel_placeholder.asp) | input::placeholder    | Selects input elements with the "placeholder" attribute specified |
| [:read-only](https://www.w3schools.com/cssref/sel_read-only.asp) | input:read-only       | Selects input elements with the "readonly" attribute specified |
| [:read-write](https://www.w3schools.com/cssref/sel_read-write.asp) | input:read-write      | Selects input elements with the "readonly" attribute NOT specified |
| [:required](https://www.w3schools.com/cssref/sel_required.asp) | input:required        | Selects input elements with the "required" attribute specified |
| [:root](https://www.w3schools.com/cssref/sel_root.asp)       | :root                 | Selects the document's root element                          |
| [::selection](https://www.w3schools.com/cssref/sel_selection.asp) | ::selection           | Selects the portion of an element that is selected by a user |
| [:target](https://www.w3schools.com/cssref/sel_target.asp)   | #news:target          | Selects the current active #news element (clicked on a URL containing that anchor name) |
| [:valid](https://www.w3schools.com/cssref/sel_valid.asp)     | input:valid           | Selects all input elements with a valid value                |
| [:visited](https://www.w3schools.com/cssref/sel_visited.asp) | a:visited             | Selects all visited links                                    |



## 2.3. 폰트, 텍스트

### 1) 속성-typography

---

#### 들어가기 전에

> HTML이 처음 등장했을 때는 이미지를 표현하는 기능도 없는 문자만 존재하는 미디어였습니다.
>
> 그러므로 HTML에서 서체와 관련된 부분은 가장 밀접한 분야이면서 동시에 속성의 빈도수도 가장 많습니다.
>
> 폰트 속성, 텍스트 속성, 간격 관련 속성 등 다양한 서체 관련 속성이 있습니다.
>
> 이번 강에서는 폰트의 기본이 되는 타이포그래피의 구조에 대해 알아보도록 하겠습니다.

#### 핵심 키워드

> - baseline
> - ascender
> - descender
> - x-height 

#### 학습하기

---

**타이포그래피의 구조**

[![img](https://cphinf.pstatic.net/mooc/20180930_2/1538299310812y3Shi_PNG/11123.png?type=w760)](https://www.edwith.org/boostcourse-ui/lecture/33530/#)



폰트를 이해하기 위해서는 타이포그래피의 구조를 먼저 이해해야 합니다.  

모든 폰트는 em박스를 가지고 있고 위 그림과 같은 구조로 이루어져 있습니다. 

 •em 폰트의 전체 높이를 의미합니다. 

•ex ( = x-height ) 해당 폰트의 영문 소문자 x의 높이를 의미합니다. 

•Baseline 소문자 x를 기준으로 하단의 라인을 의미합니다. 

•Descender 소문자에서 baseline 아래로 쳐지는 영역을 의미합니다. 서체에 따라 descender의 길이가 다릅니다. ( g, j, p, q, y ) 

•Ascender 소문자 x의 상단 라인 위로 넘어가는 영역을 의미합니다. ( b, d, h, l )

### 2) 속성-font-family

---

#### 들어가기 전에

> font-family는 상속되기 때문에 기본적으로 대표 폰트를 선언하고,
>
> 특정 폰트가 필요한 부분에서 재정의해서 사용합니다.
>
> 구문을 사용하면서 주의해야 할 사항들이 있습니다.
>
> 이 부분에 유의하여 강의에 집중하면 좋을 것 같습니다.

#### 핵심 키워드

> - family-name
> - generic-family
> - serif
> - sans-serif

#### 학습하기

---

**font-family 속성**

글꼴을 지정하는 속성입니다.

```css
font-family: family-name | generic-family ( | initial | inherit );
```

- **family-name**: 사용할 폰트의 이름을 나타내며 ' , ' 로 구분하여 여러 개 선언 할 수 있습니다. 먼저 선언된 순서대로 우선순위가 결정됩니다. 이름 중간에 공백이 있거나, 한글일 경우 홑따옴표로 묶어서 선언합니다.

  

- **generic-family:** family-name으로 지정된 글꼴을 사용할 수 없을 경우를 대비해, **브라우저가 대체할 수 있는 폰트가 필요한 경우 선택할 수 있게** 해줍니다. font-family 속성의 맨 마지막에 선언해야 하며, 키워드이기 때문에 따옴표 등의 인용부호로 묶지 않는 것이 원칙입니다. 예를 들면 아래와 같이 선언하여 사용할 수 있습니다. 



```css
font-family: Helvetica, Dotum, '돋움', Apple SD Gothic Neo, sans-serif; 
```

가장 먼저 Helvetica를 사용하고, 이를 사용할 수 없을 때 Dotum을 사용하는 방식으로 우선순위에 따라 차례대로 적용 됩니다. **만약 "abc 가나다 123" 이라는 글자가 있다면, "abc"와 "123"은 Helvetica로 표현이 되고, "가나다"는 Dotum으로 표현**이 됩니다.
"가나다"가 Dotum으로 표현된 이유는 **Helvetica는 한글을 지원하는 폰트가 아니기 때문**입니다.

그리고 예를 보면 돋움체를 영문으로 한번, 한글로 한번 선언 하였습니다. 왜 이렇게 선언 하였을까요? **한글을 지원하지 않는 디바이스일 경우 해당 한글 폰트를 불러올 수 없으므로 영문명으로도 선언해 주어야합니다**. 

**마지막에는 반드시 generic-family를 선언 해주어야 합니다. 그 이유는 선언된 모든 서체를 사용할 수 있다는 보장이 없기 때문**입니다. 이때 generic-family를 선언해주면, 시스템 폰트 내에서 사용자가 의도한 스타일과 유사한 서체로 적용되기 때문입니다. **또한, 자식 요소에서 font-family를 재선언하면 부모에 generic-family가 선언되어있어도 다시 선언해주어야 합니다.**

Generic-Family에는 대표적인 서체로 serif, sans-serif가 있습니다. serif는 삐침이라는 뜻이고, sans는 프랑스어로 '~이 없이'라는 의미가 있습니다. **serif는 글자 획에 삐침이 있는 폰트로 대표적으로 명조체**가 있으며, **sans-serif는 획에 삐침이 없는 폰트로 대표적으로 돋움체**가 있습니다.

 

**생각해보기**

- 디바이스마다 지원하는 폰트의 종류가 다르고, 같은 폰트여도 폰트 명이 다를 수도 있습니다. 디바이스별 대표 폰트들과 지원 범위를 잘 확인해보시기 바랍니다.

  

### 3) 속성-line-height

---

#### 들어가기 전에

> 장문의 글에서는 가독성을 위해서 글 사이의 간격을 띄우기도 합니다.
>
> 이때 행간을 조정한다고 하는데요.
>
> line-height 속성을 이용해 이 행간을 조정할 수 있습니다.
>
> 그러나 정확하게 line-height는 줄의 높이를 의미하는 것이고, 이를 이용해서 행간을 조정할 수 있는 것입니다.
>
> 이 속성이 어떤 방식으로 동작하는지에 대해 알아보도록 하겠습니다.

#### 핵심 키워드

> - number
> - percent

#### 학습하기

---

**line-height 속성**

line-height는 텍스트 라인의 높이를 의미하는 것으로 주로 행간을 제어할 때 사용됩니다.

  기본 값 : normal

```css
line-height: normal | number | length | initial | inherit ;
```

[![img](https://cphinf.pstatic.net/mooc/20180925_292/1537812871995OXjoa_PNG/1234.png?type=w760)](https://www.edwith.org/boostcourse-ui/lecture/33532/#)

**행간**을 제어할 때 사용하는 속성이라 해서 줄 간격으로 생각해 오해하기 쉬울 수가 있습니다.

줄 바꿈이 되었을 때, 윗줄의 텍스트 하단과 아랫줄의 텍스트 상단까지의 간격이라고 생각할 수도 있지만,

line-height로 제어되는 부분을 line-box라고도 하며 이는 타이포그래피 구조에서 배웠던 **[em 박스] + [상하단의 여백]까지를 의미**합니다. 

*<* *속성 값 >*

| **normal** | 기본값으로 브라우저의 기본 속성을 따릅니다.폰트에 따라 브라우저에 따라 다르지만 보통 1.2 정도로 할당되어 있습니다. |
| ---------- | ------------------------------------------------------------ |
| **number** | font-size를 기준으로 설정한 숫자만큼 배율로 적용합니다.      |
| **length** | px, em 등 고정 수치로 할당할 수 있습니다.                    |
| **%**      | font-size를 기준으로 설정한 퍼센트만큼 배율로 적용합니다.    |

주의할 점은, line-height의 값으로 number를 선언할 때와 %로 선언할 때의 차이입니다.

**두 값 모두 font-size를 기준으로 동작하기 때문에** 1이나 100%를 같은 것이라고 오해할 수 있습니다.

하지만 **두 값은 큰 차이가 있습니다. 바로 line-height의 값이 자식 요소로 상속되었을 때의 계산 방식**입니다. 



- **number** 부모 요소의 **숫자 값이 그대로 상속**됩니다. 즉, 자식 요소에서도 **또 한 번 자식 요소의 font-size를 기준으로 계산된 값**을 가집니다.

  

- **%** 부모 요소에서 %값이 그대로 상속되는 것이 아니고, **%에 의해 이미 계산된 px값이 상속**됩니다.

  

아래 코드를 예시로 보자면,

```css
body { font-size: 20px; line-height: 2; }       /* line-height = 40px; */
body { font-size: 20px; line-height: 200%; }    /* line-height = 40px; */
```

두 경우 모두 \<body>에 똑같이 line-height: 40px이 적용됩니다.

하지만 자식 요소로 \<p>가 있다고 생각을 하면 얘기가 달라집니다.

```css
body { font-size: 20px; line-height: 2; }    /* line-height = 40px; */
p { font-size: 10px; }                                  /* line-height = 20px; */


body { font-size: 20px; line-height: 200%; }    /* line-height = 40px; */
p { font-size: 10px; }                                          /* line-height = 40px; */
```

이처럼 계산된 값이 아닌 숫자 값을 상속한다는 사실 때문에,

**숫자 값을 사용하면 부모 엘리먼트에서 계산된 값 대신 비율을 그대로 상속받을 수 있으므로,**

**가능하면 단위가 없는 값을 사용하는 것이 좋**습니다.

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>line-height</title>
  <style>
    .parent {
        width: 200px;
        font-size: 10px;
  
        line-height: normal;
        line-height: 20px;
        line-height: 2;
        line-height: 200%;
    }

    .child {
        font-size: 20px;
    }
  </style>
</head>

<body>
  <div class="parent">
    <div class="child">
      Lorem ipsum dolor sit amet consectetur adipisicing elit. 
      Ipsam aspernatur vitae sapiente laudantium velit quo unde cupiditate autem, 
      harum eaque natus perferendis ducimus saepe libero, voluptatibus voluptates possimus.
      Adipisci, delectus.
    </div>
  </div>
</body>
</html>
```



### 4) 속성-font-size

---

#### 들어가기 전에

> 텍스트를 많이 사용하는 html 문서에서 font-size 속성은 가독성이나 명확한 구문을 표현하기 위해서 반드시 필요한 속성입니다.
>
> 글꼴의 크기를 지정하는 font-size 속성에는 다양한 값들이 있습니다.
>
> 이 값들의 특징과 단위에 따른 폰트 사이즈의 변화를 알아보도록 하겠습니다.

#### 핵심 키워드

> - absolute size
> - relative size
> - viewport units

#### 학습하기

---

**font-size 속성**

글꼴의 크기를 지정하는 속성입니다.

  기본 값 : medium

```css
font-size: keyword | length | initial | inherit ;
```

 *<* *속성 값 >*

| **keyword** | medium(기본 값), xx-small, x-small, small, large, x-large, xx-large, smaller, larger |
| ----------- | ------------------------------------------------------------ |
| **length**  | px, em 등 고정 수치로 지정합니다.                            |
| **%**       | 부모 요소의 font-size 기준의 퍼센트로 지정합니다.            |

 

- **absolute size (keyword)** 기본 값인 medium에 대한 상대적인 크기로, **브라우저마다 사이즈가 다르게 정의**되어있습니다.
- **relative size (keyword)** 부모 요소의 font-size 크기에 대해 상대적입니다. smaller는 0.8배, larger는 1.2배입니다.
- **length** px, em, rem 등의 단위를 이용하여 고정된 크기를 지정할 수 있습니다. - em : 부모 요소의 font-size에 em 값을 곱한 크기 - rem : 루트의 font-size에 rem 값을 곱한 크기
- **percent (%)** 부모 요소의 font-size를 기준으로 백분율 계산된 값을 지정할 수 있습니다.
- **viewport units** vw, vh 단위로 뷰포트를 기준으로 하여, **유동적인 font-size를 지정**할 수 있습니다. vw는 뷰포트 width의 1%, vh는 뷰포트 height의 1% 값을 가집니다.

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>font-size</title>
  <style>
    .parent {
        font-size: 20px;
    }
    .child {
        font-size: 1em;
    }
  </style>
</head>
<body>
  <div class="parent">
    <div class="child">
      Lorem ipsum dolor sit amet consectetur adipisicing elit. 
      Ipsam aspernatur vitae sapiente laudantium velit quo unde cupiditate autem, 
      harum eaque natus perferendis ducimus saepe libero, voluptatibus voluptates possimus.
      Adipisci, delectus.
    </div>
  </div>
</body>
</html>
```

------



**생각해보기**

- font-size에는 em 단위와 % 단위를 사용할 수 있는데요. 둘 다 부모 요소의 font-size를 기준으로 그 값이 곱해지기 때문에 font-size 속성에서는 두 단위의 동작이 같아 보일 수 있습니다. 그러나 다른 속성에서 이 단위들이 사용될 때는 그 기준이 명확하게 달라집니다. 이 차이에 대해 유념하시면 좋을 것 같습니다.

  

### 5) 속성-font-weight

---

#### 들어가기 전에

> 시멘틱 태그 중 heading( h1 ~ h6 ), strong 태그들을 사용했을 때 글씨가 굵게 표현되는 것을 보셨을 겁니다.
>
> 분명히 아무런 스타일도 입히지 않았는데 왜 이렇게 표현이 되는 걸까요?
>
> 우리는 흔히 글을 쓸 때 중요한 부분이나 강조하고 싶을 때 폰트를 굵게 표시하곤 합니다.
>
> 브라우저도 위의 태그들이 시멘틱하게, 중요하다고 판단되어 굵게 표시하는 것으로 생각하면 되는데요.
>
> 이때 font-wieght라는 속성에 의해서 위와 같이 표현되었던 것입니다.
>
> 앞의 태그들이 font-weight에서 굵게 표현되는 속성을 기본값으로 가지고 있기 때문입니다.

#### 핵심 키워드

> - normal
> - bold

#### 학습하기

---

**font-weight 속성**

글꼴의 굵기를 지정하는 속성입니다.

 

  기본 값 : normal

```css
font-weight: normal | bold | bolder | lighter | number | initial | inherit ;
```

 

*<* *속성 값 >*

| **normal**  | 기본 값 (400)                                                |
| ----------- | ------------------------------------------------------------ |
| **bold**    | 굵게 표현(700)                                               |
| **bolder**  | 부모 요소 보다 두껍게 표현                                   |
| **lighter** | 부모 요소 보다 얇게 표현                                     |
| **number**  | 100, 200, 300, 400, 500, 600, 700, 800, 900 (클수록 더 두껍게 표현) |

**실무에서는 normal과 bold를 많이** 사용하고, **부모 요소에 영향이 있는 bolder와 lighter는 사용을 될 수 있으면 지양**하는 편입니다.

물론 상속 관계에서 바뀌어야 하는 스펙이라면 당연히 유용하게 사용될 수 있지만, 그 외의 경우에는 사용에 있어 신중해야 합니다. 

font-weight는 normal, bold와 같은 키워드 외에 숫자로도 그 굵기를 표현할 수 있습니다.

100~900까지 100단위로 값을 지정하여 사용할 수 있고 숫자가 커질수록 더욱 굵게 표현됩니다.

**기본적으로 400은 normal과 같고, 700은 bold**와 같습니다

**그러나 수치를 이용한 font-weight는 폰트 자체에서 지원을 해야 표현할 수 있습니다.**

폰트에 따라 font-weight를 적용해도 굵기에 변화가 없을 수도 있으며,

normal과 bold만 지원하는 폰트일 경우에는 100~500까지는 normal로, 600~900까지는 bold로 표현됩니다.

**폰트가 점차 다양해지면서 굵기 자체를 폰트 family-name으로 가지고 있는 경우도 있습니다.**

**또한, 디바이스별로 조금 다르게 표현될 수도 있습니다.** 

**font-weight와 font-family, font-size는 서로 밀접하게 연관되어있습니다.**

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>font-size</title>
  <link href='//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800,300' rel='stylesheet' type='text/css'>
  <style>
    body {  
       padding: 0 20px;     
       font-family: 'Open Sans'; 
    }
    .w100 {  font-weight: 100;  }
    .w200 {   font-weight: 200;  }
    .w300 { font-weight: 300;  }
    .w400 {  font-weight: 400;  }
    .w500 {  font-weight: 500;  }
    .w600 { font-weight: 600;  }
    .w700 { font-weight: 700;  }
    .w800 {  font-weight: 800;  }
    .w900 {  font-weight: 900;  }
  </style>
</head>
<body>
  <p class="w100">This is 100 weight</p>
  <p class="w200">This is 200 weight</p>
  <p class="w300">This is 300 weight (available)</p>
  <p class="w400">This is 400 weight (available)</p>
  <p class="w500">This is 500 weight</p>
  <p class="w600">This is 600 weight (available)</p>
  <p class="w700">This is 700 weight (available)</p>
  <p class="w800">This is 800 weight (available)</p>
  <p class="w900">This is 900 weight</p>
</body>
</html>

```

### 6) 속성-font-style

---

#### 들어가기 전에

> em 태그를 사용했을 때, 글꼴이 기울어지는 것을 보셨을 겁니다.
>
> em 태그는 기본적으로 font-style 속성에 italic이라는 값을 가지고 있어 기울임꼴로 표시됩니다.
>
> 이처럼 font-style 속성을 이용하면 태그의 기울임 처리를 할 수도 있습니다.

#### 핵심 키워드

> - em
> - oblique
> - italic

#### 학습하기

---

**font-style 속성**

글꼴의 스타일을 지정하는 속성입니다.

  기본 값 : normal

```css
font-style: normal | italic | oblique | initial | inherit;
```

[![img](https://cphinf.pstatic.net/mooc/20180925_282/1537815184289axaTi_PNG/12345.png?type=w760)](https://www.edwith.org/boostcourse-ui/lecture/33535/#)

*<* *속성 값 >*

| **normal**  | font-family 내에 분류된 기본 값 |
| ----------- | ------------------------------- |
| **italic**  | italic 스타일로 표현합니다.     |
| **oblique** | oblique 스타일로 표현합니다.    |

 

- oblique 텍스트의 기울기에 대한 각도를 추가로 지정할 수 있습니다.

font-weight oblique <각도>;

유효한 값은 -90 ~ 90도이며, 따로 각도를 지정하지 않으면 14도가 사용됩니다. 양수 값은 글의 끝 부분 쪽으로 기울어지며, 음수값은 시작 부분 쪽으로 기울어집니다. 그러나 아직 초안 단계로 [CSS Fonts Module Level 4](https://drafts.csswg.org/css-fonts-4/#font-style-prop)를 지원하는 브라우저에서만 사용 가능합니다.

 

------

 

**생각해보기**

- 대부분 브라우저에서 italic 스타일과 oblique 스타일을 똑같은 형태로 표현하고 있습니다.oblique는 각도를 줄 수 있지만 브라우저마다 지원하는 비율이 서로 다르다.

  

### 7) 속성-font-variant

---

#### 들어가기 전에

> font-variant 속성은 문자 변환의 의미로 이 속성을 이용해 모든 소문자를 대문자로 변환할 수 있습니다.
>
> 변환된 대문자는 실제 대문자 사이즈 보다 더 작은 사이즈로 나타나며 대소문자 변환이기 때문에 한글에는 적용되지 않습니다.

#### 핵심 키워드

> - small-caps

#### 학습하기

---

**font-variant 속성**

글꼴의 형태를 변형하는 속성으로 소문자를 작은 대문자로 변환할 수 있습니다.

  기본 값 : normal 

```css
font-variant: normal | small-caps | initial | inherit ;
```

 *<* *속성 값 >*

| **normal**     | 기본 값                            |
| -------------- | ---------------------------------- |
| **small-caps** | 소문자를 작은 대문자로 변형합니다. |

------



**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>font-variant</title>
  <style>
    p {
      font-variant: small-caps;
    }
  </style>
</head>

<body>
  <p>Font-Variant: Small-Caps</p>
</body>
</html>
```

### 8) 속성 - font

---

#### 들어가기 전에

> font의 경우 앞서 배운 font와 관련된 다양한 값을 축약 속성에 넣을 수 있습니다.
>
> 다만 속성마다 선언 순서를 지켜야 하는 제약이 있습니다.
>
> 또한, 반드시 꼭 넣어야 하는 속성들이 있는 등 지켜야 할 규칙이 많고 가독성이 좋지 않기 때문에
>
> 실무에서 선호하는 편은 아닙니다.
>
> 그렇지만 font로 선언된 속성을 보고 어떤 값들이 적용되어 있는지 해석할 수 있어야 합니다.

#### 핵심 키워드

> - 축양형 속성

#### 학습하기

---

**font 관련 속성**

font-style, font-variant, font-weight, font-size/line-height, font-family 속성들을 한 번에 선언할 수 있는 축약형 속성입니다. 

  기본 값 : 각 속성들의 기본 값

```css
font: font-style font-variant font-weight font-size/line-height font-family | initial | inherit;
```

*<* *속성 값 >*

| **font-style**            | font-style 지정, 기본 값은 normal            |
| ------------------------- | -------------------------------------------- |
| **font-variant**          | font-variant 지정, 기본 값은 normal          |
| **font-weight**           | font-weight 지정, 기본 값은 normal           |
| **font-size/line-height** | font-size/line-height 지정, 기본 값은 normal |
| **font-family**           | font-family 지정                             |

```css
/*  size | family */
font: 2em "돋움", dotum, sans-serif;

/* style | size | family */
font: oblique 2em "돋움", dotum, sans-serif;

/* style | variant | weight | size/line-height | family */
font: oblique small-caps bold 16px/1.5 '돋움';

/* The font used in system dialogs */
font: message-box;
font: icon;
```

축약형을 선언할 때는 아래 사항들을 유의해야 합니다.

- font-size와 font-family는 반드시 선언해야 하는 필수 속성입니다.
- 빠진 속성이 있다면 기본 값으로 지정됩니다.
- 각 속성의 선언 순서를 지켜야 합니다.

### 9) 속성-webfont

---

#### 들어가기 전에

> 실무에서 폰트 관련해서 주로 사용되는 명칭으로 ' 시스템 폰트 ', ' 이미지 폰트 ', ' 웹 폰트 '가 있습니다.
>
> 시스템 폰트는 font-family로 선언한 글꼴이 사용자 시스템에 기본으로 설치가 되어 있어 사용할 수 있는 경우를 말하고,
>
> 이미지 폰트는 특정 글꼴을 사용하는 것이 아니고, 글자를 표현함에 있어 시각적인 요소를 많이 넣고 싶을 때 글꼴 대신 이미지를 이용해서 표현하는 경우를 의미합니다. 정확히 얘기하면 이미지 폰트는 폰트가 아니고 이미지 입니다.
>
> 그리고 이번 강에서 다룰 웹 폰트의 경우는 서버에 저장해 제공하거나, 웹 경로를 통해 사용하는 폰트를 말합니다. 

#### 핵심 키워드

> - 시스템 폰트
> - 이미지 폰트
> - 웹 폰트
> - 확장자 

#### 학습하기

---

**@font-face**

웹에 있는 글꼴을 사용자의 로컬 환경(컴퓨터)으로 다운로드하여 적용하는 속성입니다. 

  기본 값 : 없음

```css
@font-face { 
    font-properties 
}
```

*<* *속성 값 >*

| **font-family(필수)** | 글꼴의 이름을 지정                   |
| --------------------- | ------------------------------------ |
| **src(필수)**         | 다운로드 받을 글꼴의 경로(URL)       |
| **font-style(옵션)**  | 글꼴의 스타일 지정, 기본 값은 normal |
| **font-weight(옵션)** | 글꼴의 굵기 지정, 기본 값은 normal   |

사용 예시는 다음과 같습니다.

```css
@font-face {
    font-family: webNanumGothic; /* 사용자 지정 웹 폰트명 */
    src: url(NanumGothic.eot); /* 적용 될 웹 폰트의 경로 */
    font-weight: bold; /* 필요에 따라 지정 */
    font-style: italic; /* 필요에 따라 지정 */
}

body {
    font-family: webNanumGothic;
}
```

웹폰트는 선언 시 필요에 따라 굵기나 스타일 등을 같이 지정해서 사용할 수 있습니다

 

------

 

**생각해보기**

- 앞서 말했듯이 웹폰트의 확장자별로 지원범위가 다릅니다. 예시 코드에서는 eot 확장자의 파일 한 개만을 사용하였지만, 여러 종류의 웹폰트를 동시에 선언하여 사용할 수 있습니다. 또한, 선언된 순서에 따라 어떻게 동작하는지 확인해보시기 바랍니다.



### 10) 속성-vertical-align

---

#### 들어가기 전에

> css를 통해서 텍스트를 수직, 수평 정렬 할 수 있습니다.
>
> 그 중 vertical-align 속성을 이용하여 수직 정렬을 할 수 있습니다.
>
> 이때 주의하실 점은 block 요소가 아닌 inline 또는 inline-block에서만 사용할 수 있습니다.
>
> 따라서 display이 속성이 변하지 않은 div, p와 같은 블록레벨 요소에는 적용되지 않습니다.

#### 핵심 키워드

> - 수직 정렬

#### 학습하기

---

**vertical-align 속성**

요소의 수직 정렬을 지정하는 속성입니다. 

  기본 값 : baseline

```css
vertical-align: keyword | length | percent | initial | inherit ;
```

*<* *속성 값 >*

| **length**  | 요소를 지정한 길이만큼 올리거나 내림. 음수 허용              |
| ----------- | ------------------------------------------------------------ |
| **%**       | 요소를 line-height를 기준으로 올리거나 내림. 음수 허용       |
| **keyword** | baseline(기본 값), sub, super, top, text-top, middle, bottom, text-bottom |

vertical-align은 기본 값이 baseline입니다.

이전에 타이포그래피 구조 강의에서 설명했듯이 baseline은 소문자 x를 기준으로 하단 라인을 의미합니다. 

- **keyword** sub : 부모 아래 첨자 기준으로 정렬 super : 부모 위 첨자 기준으로 정렬 text-top : 부모 텍스트의 맨 위(Ascender 제외) text-bottom : 부모의 텍스트의 맨 아래(Descender 제외) middle : 부모의 중앙에 위치 top : 부모의 맨 위 위치 bottom : 부모의 맨 아래 위치

  

- **length** px값 사용 시 baseline을 기준으로 이동하며, 음수 값도 사용 가능합니다.

  

- **percent ( % )** line-height를 기준으로 내에서 이동하며 음수 값 사용 가능합니다.

 주의하실 점은 block 요소가 아닌 inline 또는 inline-block에서만 사용할 수 있습니다.

따라서 display이 속성이 변하지 않은 div, p와 같은 블록레벨 요소에는 적용되지 않습니다.

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>vertical-align</title>
  <style>
    p {
      padding: 10px;
      border: 1px dashed #aaa;
      line-height: 1;
      font-size: 16px;
    }

    p span {
      background-color: rgba(0, 255, 255, 0.5);
      border: 1px solid #aaa;
    }

    p span:nth-child(1) {
      background-color: rgba(255, 255, 0, 0.5);
    }

    p span:nth-child(2),
    p span:nth-child(4) {
      font-weight: bold;
      font-size: 20px;
    }

    p span:nth-child(3) {
      background-color: rgba(0, 0, 0, 0.2);
    }

    /* table */

    table {
      width: 100%;
      border-collapse: collapse;
    }

    table td,
    table th {
      border: 1px solid #aaa;
      height: 50px;
    }
  </style>
</head>
<body>
    <h1>vertical-align</h1>
    <p><span>vertical-align:</span>
      <span style="vertical-align: baseline;">baseline;</span>
      <span>---</span>
      <span style="vertical-align: baseline;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: sub;">sub;</span>
      <span>---</span>
      <span style="vertical-align: sub;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: super;">super;</span>
      <span>---</span>
      <span style="vertical-align: super;">수직정렬</span></p>
    <p>
      <span>vertical-align:</span>
      <span style="vertical-align: text-top;">text-top;</span>
      <span>---</span>
      <span style="vertical-align: text-top;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: text-bottom;">text-bottom;</span>
      <span>---</span>
      <span style="vertical-align: text-bottom;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: middle;">middle;</span>
      <span>---</span>
      <span style="vertical-align: middle;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: top;">top;</span>
      <span>---</span>
      <span style="vertical-align: top;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: bottom;">bottom;</span>
      <span>---</span>
      <span style="vertical-align: bottom;">수직정렬</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: 4em;">4em;</span>
      <span>---</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: 4px;">4px;</span>
      <span>---</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: 20%;">20%;</span>
      <span>---</span></p>
    <p><span>vertical-align:</span>
      <span style="vertical-align: -10px;">-10px;</span>
      <span>---</span></p>

    <table>
      <caption>table cell vertical-align</caption>
      <thead>
        <tr>
          <th>속성 값</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="vertical-align:baseline;">vertical-align:baseline</td>
        </tr>
        <tr>
          <td style="vertical-align:top;">vertical-align:top</td>
        </tr>
        <tr>
          <td style="vertical-align:middle;">vertical-align:middle(cell 기본값)</td>
        </tr>
        <tr>
          <td style="vertical-align:bottom;">vertical-align:bottom</td>
        </tr>
        <tr>
          <td>null</td>
        </tr>
      </tbody>
    </table>
</body>
</html>
```



### 11) 속성-text-align

---

#### 들어가기 전에

> 앞서 배운 vertical-align이 인라인 요소의 수직 정렬이었다면, text-align은 인라인 요소의 수평 정렬에 사용됩니다.
>
> 이 속성 또한 div와 같은 블록 레벨 요소에는 적용되지 않습니다.

#### 핵심 키워드

> - 텍스트 정렬
> - 인라인 요소

#### 학습하기

---

**text-align 속성**

텍스트의 정렬을 지정하는 속성입니다. 

  기본 값 : left (Right to Left 언어일 경우는 right)

```css
text-align: left | right | center | justify | initial | inherit ;
```

기본 값은 left이지만 경우에 따라 다릅니다.

문서의 방향이 LTR(Left To Right) 왼쪽에서 오른쪽 방향인 언어일 경우 left가 기본값이고,

RTL(Right To Left) 로 오른쪽에서 왼쪽으로 읽힐 경우 right가 기본값이 됩니다. 

*<* *속성 값 >*

| **left**    | 텍스트를 왼쪽으로 정렬                                       |
| ----------- | ------------------------------------------------------------ |
| **right**   | 텍스트를 오른쪽으로 정렬                                     |
| **center**  | 텍스트를 중앙으로 정렬                                       |
| **justify** | 텍스트를 라인 양쪽 끝으로 붙여서 정렬. (마지막 라인은 정렬 하지 않음) |

 

**text-align과 display의 관계**

 \- text-align은 inline-level에 적용

 \- text-align은 **block-level에 적용할 수 없음** 

그렇다면 block 요소를 가운데 정렬 하고자 한다면 어떻게 해야 할까요?

박스모델 챕터에서 다룬 **margin의 auto 값**을 이용해서 하시면 됩니다. 

- **가운데 정렬**

  인라인 요소 : text-align (center)

  블럭 요소 : margin (auto) 

요소의 레벨에 따라 정렬하는 방식의 차이를 바로 알고 있으시기 바랍니다.

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>text-align</title>
  <style>
    p {
      max-width: 630px;
      border: 1px solid #888;
      padding: 10px;
    }
  </style>
</head>
<body>
  <h1>text-align</h1>
  <h2>left</h2>
  <p style="text-align: left;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
  <h2>right</h2>
  <p style="text-align: right;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
  <h2>center</h2>
  <p style="text-align: center;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
  <h2>justify</h2>
  <p style="text-align: justify;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
</body>
</html>
```

### 12) 속성-text-indent

---

#### 들어가기 전에

> 문서나 코드를 살펴보면 새로운 문단의 시작에서 들여쓰기를 많이 사용합니다.
>
> 들여쓰기는 문단의 처음 왼쪽 글머리에 빈칸을 만들어 가독성을 향상하는 효과가 있습니다.
>
> text-indent를 이용해서 문장의 첫 줄을 들여쓰기할 수 있습니다.

#### 핵심 키워드

> - 들여쓰기

#### 학습하기

---

**text-indent 속성**

텍스트의 들여쓰기를 지정하는 속성입니다. 

  기본 값 : 0

```css
text-indent: length | initial | inherit;
```

*<* *속성 값 >*

| **length** | px, em 등 고정 수치로 지정. 음수 허용      |
| ---------- | ------------------------------------------ |
| **%**      | 부모 요소의 width를 기준으로 퍼센트로 지정 |

 

- **length** 문단의 첫 줄에 대한 들여쓰기를 수행합니다. 음수 값을 사용할 수 있으며, 음수 값 사용 시 왼쪽으로 이동합니다.

  

- **percent ( % )** 텍스트를 포함하는 컨테이너 블록의 width(부모의 width)를 기준으로 변환된 백분율 값으로 들여쓰기합니다.

 

------

 

**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>text-indent</title>
</head>
<body>
  <h1>text-indent</h1>
  <h2>length 1em</h2>
  <p style="text-indent: 1em;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
  <h2>length 40px</h2>
  <p style="text-indent: 40px;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
  <h2>percentage 15%</h2>
  <p style="text-indent: 15%;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.</p>
  <h2>length -40px (비추천)</h2>
  <p style="text-indent:-40px;">이 안내서를 시작하기 전에, 사용법에 익숙한 텍스트 파일을 편잡할 수 있는 편집 툴이 필요하며 최신 브라우저도 필요하다. 파일을 편집하고 싶지 않다면 그냥 안내서를 읽고 해당 예시 그림을 보라. 그러나 배우는데는 더딜 것이다.<br>들여쓰기에 음수사용은 올바르지 않으며 본래의 기능에서 벗어남</p>
</body>
</html>
```

### 13) 속성-text-decoration

---

#### 들어가기 전에

> <a>를 사용하면 기본적으로 텍스트 밑에 밑줄이 그어져서 표시되는 것을 보신 적이 있으실 겁니다.
>
> 이러한 이유는 브라우저에 따라 다를 수는 있지만 보통 text-decoration이
>
> <a>에 대해서 기본값이 다르기 때문입니다.
>
> 이 속성은 단순 밑줄을 그어주는 것이 아니라 다양한 줄의 스타일과 모양,
>
> 색상 등을 제어할 수 있습니다.

#### 핵심 키워드

> - 텍스트의 꾸밈
> - 밑줄의 종류

#### 학습하기

---

**text-decoration 속성**

텍스트의 장식을 지정하는 속성입니다. 아래 속성들의 단축 속성으로, 기본 값은 차례대로 아래 3가지 속성의 값입니다. 

  기본 값 : none  currentColor  solid

```css
text-decoration: text-decoration-line text-decoration-color text-decoration-style | initial | inherit;
```

- **text-decoration-line** 텍스트 꾸밈의 종류를 지정하는 속성입니다.   
- 기본 값 : none 

*<* *속성 값 >*

| **none**         | 텍스트 꾸밈을 생성하지 않음 ( 기본값 ) |
| ---------------- | -------------------------------------- |
| **underline**    | 밑줄로 꾸밈을 설정                     |
| **overline**     | 윗줄로 꾸밈을 설정                     |
| **line-through** | 중간을 지나는 줄로 꾸밈을 설정         |

- **text-decoration-color**

- 텍스트 꾸밈의 색상을 지정하는 속성입니다.   

- 기본 값 : currentColor

- 색상 값을 사용하여 원하는 색상을 지정할 수 있습니다.

  

- **text-decoration-style**

- 꾸밈에 사용되는 선의 스타일을 지정하는 속성입니다.   

- 기본 값 : solid 

*<* *속성 값 >*

| **solid**  | 한줄 스타일 ( 기본 값 ) |
| ---------- | ----------------------- |
| **double** | 이중선 스타일           |
| **dotted** | 점선 스타일             |
| **dashed** | 파선 스타일             |
| **wavy**   | 물결 스타일             |

------



**코드실습**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>text-decoration</title>
</head>
<body>
  <h2>일반 경우</h2>
  <p style="text-decoration: overline;"> 
  text-decoration: overline;
  </p>
  <p style="text-decoration: underline;"> 
  text-decoration: underline;
  </p>
  <p style="text-decoration: line-through;"> 
  text-decoration: line-through;
  </p>


  <h2>부모 내 자식요소가 float될 경우 상속이 해제됨</h2>
  <a href="#" style="text-decoration: overline;"> <span style="float:left;"> 
  text-decoration: overline;</span>
  </a>
  <br>
  <h2>부모 내 자식요소가 absolute 경우 상속이 해제됨</h2>
  <a href="#" style="text-decoration: overline;"> <span style="position:absolute;"> 
  text-decoration: overline;</span>
  </a>
</body>
</html>
```

### 14) 속성-단어 관련 속성

---

#### 들어가기 전에

> CSS에는 앞에서 배운 font와 관련된 텍스트에 대한 속성뿐만아니라, 단어에 대해서
>
> 어떻게 표현되게 할지 지정할 수 있습니다.
>
> 간단하게 보고가자면, 단어의 공백을 어떻게 처리할지, 단어 사이의 간격을 얼마만큼
>
> 가질지, 줄 바꿈이 되는 지점은 어디로 둘지 등을 제어할 수 있습니다.
>
> 이러한 속성들에 대해서 살펴보도록 하겠습니다.

#### 핵심 키워드

> - white-space
> - letter-spacing
> - word-spacing
> - word-break
> - word-wrap 

#### 학습하기

---

**white-space 속성**

요소 안에 공백을 어떻게 처리할지 지정하는 속성입니다.

  기본 값 : normal

```css
white-space: normal | nowrap | pre | pre-line | pre-wrap | initial | inherit;
```

*<* *속성 값 >*

| **normal**   | 공백과 개행을 무시하고, 필요한 경우에 자동 줄바꿈 발생. 기본 값 |
| ------------ | ------------------------------------------------------------ |
| **nowrap**   | 공백과 개행을 무시하고, 자동 줄바꿈이 일어나지 않음.         |
| **pre**      | 공백과 개행을 표현하고, 자동 줄바꿈이 일어나지 않음.         |
| **pre-line** | 공백은 무시하고, 개행만 표현. 필요한 경우에 자동 줄바꿈 발생. |
| **pre-wrap** | 개행은 무시하고, 공백만 표현. 필요한 경우 자동 줄바꿈 발생.  |

 

**letter-spacing 속성**

자간을 지정하는 속성입니다.

  기본 값 : normal

```css
letter-spacing: normal | length | initial | inherit;
```

*<* *속성 값 >*

| **normal** | 기본 값                         |
| ---------- | ------------------------------- |
| **length** | 길이만큼 자간을 지정. 음수 허용 |

 

**word-spacing 속성**

단어 사이의 간격을 지정하는 속성입니다.

  기본 값 : normal

```css
word-spacing: normal|length|initial|inherit;
```

*<* *속성 값 >*

| **normal** | 기본 값                                     |
| ---------- | ------------------------------------------- |
| **length** | 길이만큼 단어 사이의 간격을 지정. 음수 허용 |

 

**word-break 속성**

단어가 라인 끝에 나올 경우 어떻게 처리할지(중단점) 지정하는 속성입니다.

  기본 값 : normal

```css
word-break: normal | break-all | keep-all | initial | inherit;
```

*<* *속성 값 >*

| **normal**    | 기본 값. 중단점은 공백이나 하이픈(-)(CJK는 음절)     |
| ------------- | ---------------------------------------------------- |
| **break-all** | 중단점은 음절. 모든 글자가 요소를 벗어나지 않고 개행 |
| **keep-all**  | 중단점은 공백이나 하이픈(-)(CJK는 그 외 기호도 포함) |

 

**word-wrap 속성**

요소를 벗어난 단어의 줄바꿈을 지정하는 속성입니다.

 기본 값 : normal

```css
word-wrap: normal|break-word|initial|inherit;
```

*<* *속성 값 >*

| **normal**     | 기본 값. 중단점에서 개행                     |
| -------------- | -------------------------------------------- |
| **break-word** | 모든 글자가 요소를 벗어나지 않고 강제로 개행 |

